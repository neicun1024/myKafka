# myKafka

## 一、为什么要使用消息队列

### 1. 同步的方式存在的问题
- 造成的系统开销-响应时间是比较大的（2-5s）
- 在同步的过程中要保证每个服务都顺利执行完，整个链路才执行完，因为网络等其它问题，整个链路成功执行完的成功率会受影响，导致用户体验较差

同步的通信方式会存在性能和稳定性的问题。

### 2. 异步的优势
- 明显提升系统的吞吐量
- 即使有服务失败，也可以通过分布式事务解决方案来保证最终是成功的

针对同步的通信方式来说，异步的方式，可以让上游快速成功，极大提高了系统的吞吐量。并且在分布式系统中，通过下游多个服务的分布式事务的保障，也能保障业务执行之后的最终一致性。


### 3. 消息队列解决的是什么问题
异步通信问题


## 二、消息队列的流派

目前消息队列中间件选型有很多种：
- RabbitMQ：比较简单，但是内部的可玩性（功能性）使非常强的
- RocketMQ：阿里内部一个大神，根据Kafka的内部执行原理，手写的一个消息队列中间件。性能与Kafka相比肩，除此之外，相比Kafka封装了更多的功能
- Kafka：全球消息处理性能最快的一款MQ
- ZeroMQ：

这些消息队列中间件有什么区别？

### 1. 有Broker的MQ
这个流派通常有一台服务器作为Broker，所有的消息都通过它中转。生产者把消息发送给它就结束自己的任务了，Broker则把消息主动推送给消费者（或者消费者主动轮询）。

#### 重Topic（Kafka、RocketMQ、ActiveMQ）
生产者会发送key和数据到Broker，由Broker比较key之后决定给哪个消费者。这种模式是我们最常见的模式，是我们对MQ最多的印象。在这种模式下，一个topic往往是一个比较大的概念，甚至一个系统中就可能只有一个topic，topic某种意义上就是queue，生产者发送key相当于说：“hi，把数据放到key的队列中”。

整个Broker依据topic来进行消息的中转。在重topic的消息队列里必然需要topic的存在。

#### 轻Topic（RabbitMQ）
生产者发送key和数据，消费者定义订阅的队列，Broker收到数据之后会通过一定的逻辑计算出key对应的队列，然后把数据交给队列。

内部有很多种模式，topic只是其中一种中转模式。

### 2. 无Broker的MQ（ZeroMQ）
ZeroMQ被设计成一个“库”而不是一个中间件，这种实现也可以达到没有Broker的目的。

节点之间通讯的消息都是发送到彼此的队列中，每个节点都既是生产者又是消费者。ZeroMQ做的事情就是封装出一套类似于Socket的API，可以完成发送数据，读取数据。


## 三、Kafka的基本知识

### 1. Kafka的安装